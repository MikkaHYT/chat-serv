<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pictionary</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --accent: #7209b7;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #4cc9f0;
            --warning: #f72585;
            --info: #4895ef;
            --gray: #dee2e6;
            --gray-dark: #343a40;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--light);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        /* USERNAME GATE */
        #username-gate {
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 400px;
            max-width: 90%;
            backdrop-filter: blur(10px);
            animation: slideIn 0.5s ease;
            margin-top: 20vh;
        }

        #username-gate h2 {
            margin-bottom: 20px;
            font-size: 28px;
            font-weight: 700;
        }

        #username-input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }

        #username-input:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.3);
        }

        #join-game {
            padding: 15px 30px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            width: 100%;
        }

        #join-game:hover {
            background: #3db5db;
            transform: translateY(-2px);
        }

        /* GAME CONTAINER */
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100vh;
            max-height: 100vh;
            padding: 20px;
            transition: all 0.5s;
        }

        .game-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 28px;
            font-weight: 700;
            display: flex;
            align-items: center;
        }

        .game-title svg {
            margin-right: 10px;
        }

        .game-status {
            font-size: 20px;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            font-weight: 500;
            gap: 10px;
            backdrop-filter: blur(5px);
        }

        .timer {
            font-weight: 700;
            color: var(--warning);
        }

        .game-content {
            display: flex;
            width: 100%;
            max-width: 1200px;
            gap: 20px;
            height: calc(100vh - 150px);
        }

        /* DRAWING AREA */
        .drawing-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .toolbar select, .toolbar button, .toolbar input {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        .toolbar select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 30px;
        }

        .toolbar button.active {
            background: var(--accent);
            color: white;
        }

        .toolbar button:hover, .toolbar select:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        #color-picker {
            height: 36px;
            width: 36px;
            border: 2px solid white;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            background: transparent;
        }

        #host-controls {
            padding: 8px 12px;
            background: var(--accent);
            border-radius: 8px;
            margin-left: 10px;
        }

        #ready-up {
            background: var(--success);
            font-weight: 500;
            padding: 8px 15px;
        }

        #ready-up.ready {
            background: var(--warning);
        }

        #start-game {
            background: var(--warning);
            color: white;
            font-weight: 500;
            padding: 8px 15px;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        canvas {
            background: white;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            border-radius: 0 0 15px 15px;
        }

        /* SIDEBAR */
        .sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .player-list {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 15px;
            flex: none;
            height: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .player-list h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .player-count {
            background: rgba(255, 255, 255, 0.2);
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 12px;
        }

        #players {
            list-style: none;
        }

        #players li {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            transition: all 0.2s;
        }

        #players li:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--gray);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--dark);
        }

        .player-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.2);
        }

        .status-ready {
            background: var(--success);
            color: white;
        }

        .status-drawing {
            background: var(--warning);
            color: white;
            animation: pulse 2s infinite;
        }

        .host-badge {
            background: var(--accent);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }

        /* CHAT SECTION */
        .chat-section {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            flex: 1;
            backdrop-filter: blur(5px);
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .chat-header {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 500;
        }

        .chat-box {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(5px);
            word-break: break-word;
        }

        .system-message {
            background: rgba(67, 97, 238, 0.2);
            align-self: center;
            padding: 8px 12px;
            border-radius: 15px;
            margin: 5px 0;
            font-style: italic;
            max-width: 80%;
        }

        .correct-guess {
            background: rgba(76, 201, 240, 0.3);
        }

        .sender {
            font-weight: bold;
            margin-bottom: 5px;
            color: var(--success);
        }

        .guess-input {
            display: flex;
            padding: 10px;
            gap: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        #guess-input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(5px);
        }

        #guess-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
        }

        #guess-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #submit-guess {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: var(--success);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }

        #submit-guess:hover {
            background: #3db5db;
        }

        /* ANIMATIONS */
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        /* WORD REVEAL */
        .word-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            gap: 5px;
        }

        .letter-box {
            width: 30px;
            height: 40px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .letter-box.revealed {
            background: rgba(67, 97, 238, 0.3);
        }

        .letter-blank {
            width: 15px;
        }

        /* WORD SELECTION MODAL */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: rgba(33, 37, 41, 0.9);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }

        .modal h2 {
            margin-bottom: 20px;
        }

        .word-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .word-option {
            padding: 15px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s;
        }

        .word-option:hover {
            background: var(--primary);
            transform: translateY(-2px);
        }

        /* ROUND END SCREEN */
        .round-results {
            text-align: center;
            animation: slideIn 0.5s ease;
        }

        .round-results h3 {
            font-size: 24px;
            margin-bottom: 15px;
        }

        .word-reveal {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--success);
        }

        .score-list {
            list-style: none;
            margin-bottom: 20px;
        }

        .score-list li {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .score-value {
            font-weight: 700;
            color: var(--success);
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
                height: auto;
            }

            .sidebar {
                width: 100%;
                order: 2;
            }

            .drawing-section {
                order: 1;
                height: 50vh;
            }

            .player-list {
                max-height: 200px;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Username Gate -->
    <div id="username-gate">
        <h2>Join Pictionary Game</h2>
        <input type="text" id="username-input" placeholder="Enter your username" maxlength="15">
        <button id="join-game">Join Game</button>
    </div>

    <!-- Main Game Container (hidden initially) -->
    <div id="game-container" style="display: none;">
        <!-- Game Header -->
        <div class="game-header">
            <div class="game-title">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                    <path d="M2 2l7.586 7.586"></path>
                    <circle cx="11" cy="11" r="2"></circle>
                </svg>
                Pictionary
            </div>
            <div class="game-status">
                <span id="game-state">Waiting for players...</span>
                <span id="timer" class="timer">60</span>
            </div>
        </div>

        <!-- Game Content -->
        <div class="game-content">
            <!-- Drawing Section -->
            <div class="drawing-section">
                <div class="toolbar">
                    <div class="toolbar-group">
                        <select id="tool">
                            <option value="pen">Pen</option>
                            <option value="eraser">Eraser</option>
                            <option value="fill">Fill</option>
                            <option value="line">Line</option>
                            <option value="rect">Rectangle</option>
                            <option value="circle">Circle</option>
                        </select>
                        <input type="color" id="color-picker" value="#000000">
                        <select id="line-width">
                            <option value="2">2px</option>
                            <option value="4">4px</option>
                            <option value="6">6px</option>
                            <option value="10">10px</option>
                            <option value="15">15px</option>
                        </select>
                        <button id="clear-btn">Clear</button>
                        <button id="undo-btn">Undo</button>
                    </div>
                    <div class="toolbar-group">
                        <div id="host-controls" style="display: none;">
                            <select id="difficulty">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                            <button id="start-game">Start Game</button>
                        </div>
                        <button id="ready-up">Ready Up</button>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="pictionary-canvas"></canvas>
                    <!-- Word display for drawer -->
                    <div class="word-container" id="word-display" style="display: none;"></div>
                </div>
            </div>

            <!-- Sidebar: Player List and Chat -->
            <div class="sidebar">
                <!-- Player List -->
                <div class="player-list">
                    <h3>Players <span class="player-count" id="player-count">0</span></h3>
                    <ul id="players"></ul>
                </div>

                <!-- Chat Section -->
                <div class="chat-section">
                    <div class="chat-header">
                        <span>Chat & Guesses</span>
                    </div>
                    <div class="chat-box" id="chat-box"></div>
                    <div class="guess-input">
                        <input type="text" id="guess-input" placeholder="Type your guess here...">
                        <button id="submit-guess">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Word Selection Modal (hidden initially) -->
    <div id="word-selection-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Choose a word to draw</h2>
            <div class="word-options" id="word-options">
                <!-- Words will be added here dynamically -->
            </div>
        </div>
    </div>

    <!-- Round End Modal (hidden initially) -->
    <div id="round-end-modal" class="modal" style="display: none;">
        <div class="modal-content round-results">
            <h3>Round Complete!</h3>
            <div class="word-reveal" id="revealed-word">AIRPLANE</div>
            <ul class="score-list" id="score-list">
                <!-- Scores will be added here dynamically -->
            </ul>
            <p>Next round starting in <span id="countdown">5</span> seconds...</p>
        </div>
    </div>

    <script>
        // Socket connection
        const socket = io();

        // DOM Elements
        const usernameGate = document.getElementById('username-gate');
        const usernameInput = document.getElementById('username-input');
        const joinGameButton = document.getElementById('join-game');
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('pictionary-canvas');
        const ctx = canvas.getContext('2d');
        const chatBox = document.getElementById('chat-box');
        const guessInput = document.getElementById('guess-input');
        const submitGuessButton = document.getElementById('submit-guess');
        const readyUpButton = document.getElementById('ready-up');
        const startGameButton = document.getElementById('start-game');
        const difficultySelector = document.getElementById('difficulty');
        const playersList = document.getElementById('players');
        const playerCount = document.getElementById('player-count');
        const toolSelector = document.getElementById('tool');
        const colorPicker = document.getElementById('color-picker');
        const lineWidthSelector = document.getElementById('line-width');
        const clearButton = document.getElementById('clear-btn');
        const undoButton = document.getElementById('undo-btn');
        const timerElement = document.getElementById('timer');
        const gameStateElement = document.getElementById('game-state');
        const wordDisplay = document.getElementById('word-display');
        const wordSelectionModal = document.getElementById('word-selection-modal');
        const wordOptions = document.getElementById('word-options');
        const roundEndModal = document.getElementById('round-end-modal');
        const revealedWord = document.getElementById('revealed-word');
        const scoreList = document.getElementById('score-list');
        const countdownElement = document.getElementById('countdown');
        const hostControls = document.getElementById('host-controls');
        
        // Game state variables
        let username = '';
        let drawing = false;
        let isDrawer = false;
        let ready = false;
        let isHost = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentLineWidth = 2;
        let lastX, lastY;
        let drawHistory = [];
        let currentPath = [];
        let gameActive = false;
        let roundTimer = 60;
        let timerInterval;
        let wordLetters = [];
        let currentWord = '';
        let roundInProgress = false;
        let shapeStartX, shapeStartY;
        let tempCanvas = document.createElement('canvas');
        let tempCtx = tempCanvas.getContext('2d');
        
        // Check for username in URL
        window.addEventListener('load', () => {
            // Configure canvas size
            resizeCanvas();
            
            const urlParams = new URLSearchParams(window.location.search);
            const urlUsername = urlParams.get('username');

            if (urlUsername) {
                username = urlUsername.trim();
                if (username) {
                    socket.emit('join_pictionary', { username });
                    usernameGate.style.display = 'none';
                    gameContainer.style.display = 'flex';
                }
            } else {
                usernameGate.style.display = 'block';
            }
            
            // Set up temp canvas for shape drawing
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
        });
        
        // Canvas resize handler
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Redraw canvas from history when resized
            redrawCanvas();
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Join the game
        joinGameButton.addEventListener('click', () => {
            username = usernameInput.value.trim();
            if (username) {
                socket.emit('join_pictionary', { username });
                usernameGate.style.display = 'none';
                gameContainer.style.display = 'flex';
                resizeCanvas();
            }
        });
        
        // Enter key to join
        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinGameButton.click();
            }
        });

        // Ready up
        readyUpButton.addEventListener('click', () => {
            ready = !ready;
            readyUpButton.textContent = ready ? 'Cancel Ready' : 'Ready Up';
            readyUpButton.classList.toggle('ready', ready);
            socket.emit('ready_up', { username, ready });
        });

        // Start the game (host only)
        startGameButton.addEventListener('click', () => {
            if(isHost) {
                const difficulty = difficultySelector.value;
                socket.emit('start_game', { username, difficulty });
                addSystemMessage("Starting the game...");
            }
        });
        
        // Drawing tools event listeners
        toolSelector.addEventListener('change', () => {
            currentTool = toolSelector.value;
            canvas.style.cursor = currentTool === 'fill' ? 'cell' : 'crosshair';
        });
        
        colorPicker.addEventListener('input', () => {
            currentColor = colorPicker.value;
        });
        
        lineWidthSelector.addEventListener('change', () => {
            currentLineWidth = parseInt(lineWidthSelector.value);
        });
        
        clearButton.addEventListener('click', () => {
            if (isDrawer) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawHistory = [];
                currentPath = [];
                socket.emit('clear_canvas');
            }
        });
        
        undoButton.addEventListener('click', () => {
            if (isDrawer && drawHistory.length > 0) {
                drawHistory.pop(); // Remove last action
                redrawCanvas();
                socket.emit('undo_canvas');
            }
        });

        // Canvas drawing logic
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('touchend', () => {
            const mouseEvent = new MouseEvent('mouseup');
            canvas.dispatchEvent(mouseEvent);
        });
        
        canvas.addEventListener('mouseout', stopDrawing);
        
        function startDrawing(e) {
            if (!isDrawer || !roundInProgress) return;
            
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            drawing = true;
            currentPath = [];
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                
                // Add to current path
                currentPath.push({
                    type: 'start',
                    x: lastX,
                    y: lastY,
                    tool: currentTool,
                    color: currentTool === 'eraser' ? '#FFFFFF' : currentColor,
                    lineWidth: currentLineWidth
                });
                
                // Send to server
                socket.emit('start_draw', {
                    x: lastX,
                    y: lastY,
                    tool: currentTool,
                    color: currentTool === 'eraser' ? '#FFFFFF' : currentColor,
                    lineWidth: currentLineWidth
                });
            } else if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'circle') {
                shapeStartX = lastX;
                shapeStartY = lastY;
                
                // Clear the temp canvas
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            } else if (currentTool === 'fill') {
                // Perform fill
                floodFill(lastX, lastY, currentColor);
            }
        }
        
        function draw(e) {
            if (!drawing || !isDrawer || !roundInProgress) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                ctx.lineTo(x, y);
                ctx.strokeStyle = currentTool === 'eraser' ? '#FFFFFF' : currentColor;
                ctx.lineWidth = currentLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                // Add to current path
                currentPath.push({
                    type: 'draw',
                    x: x,
                    y: y
                });
                
                // Send to server
                socket.emit('draw', {
                    x: x,
                    y: y,
                    tool: currentTool,
                    color: currentTool === 'eraser' ? '#FFFFFF' : currentColor,
                    lineWidth: currentLineWidth
                });
            } else if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'circle') {
                // Clear the temp canvas
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                
                // Set drawing styles
                tempCtx.strokeStyle = currentColor;
                tempCtx.lineWidth = currentLineWidth;
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';
                
                if (currentTool === 'line') {
                    // Draw line
                    tempCtx.beginPath();
                    tempCtx.moveTo(shapeStartX, shapeStartY);
                    tempCtx.lineTo(x, y);
                    tempCtx.stroke();
                } else if (currentTool === 'rect') {
                    // Draw rectangle
                    const width = x - shapeStartX;
                    const height = y - shapeStartY;
                    tempCtx.strokeRect(shapeStartX, shapeStartY, width, height);
                } else if (currentTool === 'circle') {
                    // Draw circle
                    const radius = Math.sqrt(Math.pow(x - shapeStartX, 2) + Math.pow(y - shapeStartY, 2));
                    tempCtx.beginPath();
                    tempCtx.arc(shapeStartX, shapeStartY, radius, 0, Math.PI * 2);
                    tempCtx.stroke();
                }
                
                // Draw temp canvas to main canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                
                // Redraw all previous paths
                redrawCanvas(false);
                
                // Draw current temp shape on top
                ctx.drawImage(tempCanvas, 0, 0);
            }
            
            lastX = x;
            lastY = y;
        }
        
        function stopDrawing() {
            if (!drawing || !isDrawer || !roundInProgress) return;
            
            if (currentTool === 'pen' || currentTool === 'eraser') {
                // Add current path to history
                if (currentPath.length > 0) {
                    drawHistory.push([...currentPath]);
                }
                
                // Send to server
                socket.emit('stop_draw');
            } else if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'circle') {
                // Add the shape to history
                let shapeData = {
                    type: currentTool,
                    startX: shapeStartX,
                    startY: shapeStartY,
                    endX: lastX,
                    endY: lastY,
                    color: currentColor,
                    lineWidth: currentLineWidth
                };
                
                drawHistory.push([shapeData]);
                
                // Send to server
                socket.emit('draw_shape', shapeData);
                
                // Clear the temp canvas
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            }
            
            drawing = false;
            ctx.beginPath(); // Reset the path
        }
        
        // Flood fill algorithm
        function floodFill(x, y, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Get the target color (color at the clicked pixel)
            const targetColorPos = ((y * canvas.width) + x) * 4;
            const targetR = data[targetColorPos];
            const targetG = data[targetColorPos + 1];
            const targetB = data[targetColorPos + 2];
            const targetA = data[targetColorPos + 3];
            
            // Parse fill color
            const fill = hexToRgb(fillColor);
            
            // If target color is the same as fill color, return
            if (targetR === fill.r && targetG === fill.g && targetB === fill.b) {
                return;
            }
            
            // Queue for flood fill
            const queue = [];
            queue.push([x, y]);
            
            while (queue.length > 0) {
                const [currX, currY] = queue.shift();
                const pos = ((currY * canvas.width) + currX) * 4;
                
                // Check if this pixel matches the target color
                if (
                    currX < 0 || currX >= canvas.width ||
                    currY < 0 || currY >= canvas.height ||
                    data[pos] !== targetR ||
                    data[pos + 1] !== targetG ||
                    data[pos + 2] !== targetB ||
                    data[pos + 3] !== targetA
                ) {
                    continue;
                }
                
                // Fill the pixel
                data[pos] = fill.r;
                data[pos + 1] = fill.g;
                data[pos + 2] = fill.b;
                data[pos + 3] = 255; // Full opacity
                
                // Add adjacent pixels to queue
                queue.push([currX + 1, currY]);
                queue.push([currX - 1, currY]);
                queue.push([currX, currY + 1]);
                queue.push([currX, currY - 1]);
            }
            
            // Update the canvas
            ctx.putImageData(imageData, 0, 0);
            
            // Add to history
            drawHistory.push([{
                type: 'fill',
                x, y,
                color: fillColor
            }]);
            
            // Send to server
            socket.emit('fill', { x, y, color: fillColor });
        }
        
        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Parse RGB components
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return { r, g, b };
        }
        
        // Redraw canvas from history
        function redrawCanvas(includeTemp = true) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw all paths
            for (const path of drawHistory) {
                for (let i = 0; i < path.length; i++) {
                    const action = path[i];
                    
                    if (action.type === 'start') {
                        ctx.beginPath();
                        ctx.moveTo(action.x, action.y);
                        ctx.strokeStyle = action.color;
                        ctx.lineWidth = action.lineWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                    } else if (action.type === 'draw') {
                        ctx.lineTo(action.x, action.y);
                        ctx.stroke();
                    } else if (action.type === 'fill') {
                        // Redraw fill
                        floodFill(action.x, action.y, action.color);
                    } else if (action.type === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(action.startX, action.startY);
                        ctx.lineTo(action.endX, action.endY);
                        ctx.strokeStyle = action.color;
                        ctx.lineWidth = action.lineWidth;
                        ctx.stroke();
                    } else if (action.type === 'rect') {
                        ctx.strokeStyle = action.color;
                        ctx.lineWidth = action.lineWidth;
                        const width = action.endX - action.startX;
                        const height = action.endY - action.startY;
                        ctx.strokeRect(action.startX, action.startY, width, height);
                    } else if (action.type === 'circle') {
                        ctx.beginPath();
                        const radius = Math.sqrt(Math.pow(action.endX - action.startX, 2) + Math.pow(action.endY - action.startY, 2));
                        ctx.arc(action.startX, action.startY, radius, 0, Math.PI * 2);
                        ctx.strokeStyle = action.color;
                        ctx.lineWidth = action.lineWidth;
                        ctx.stroke();
                    }
                }
            }
            
            // Draw temp canvas
            if (includeTemp) {
                ctx.drawImage(tempCanvas, 0, 0);
            }
        }

        // Update player list
        socket.on('update_players', (players) => {
            playersList.innerHTML = '';
            playerCount.textContent = players.length;

            // Disable start button if any player is not ready or game is in progress
            if (isHost) {
                startGameButton.disabled = gameInProgress || !players.every(player => player.ready);
            }
            
            players.forEach(player => {
                const li = document.createElement('li');
                
                // Player info section
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                // Avatar (first letter of username)
                const avatar = document.createElement('div');
                avatar.className = 'player-avatar';
                avatar.textContent = player.username.charAt(0).toUpperCase();
                
                // Username
                const nameSpan = document.createElement('span');
                nameSpan.textContent = player.username;
                
                // Host badge if applicable
                if (player.isHost) {
                    const hostBadge = document.createElement('span');
                    hostBadge.className = 'host-badge';
                    hostBadge.textContent = 'Host';
                    nameSpan.appendChild(hostBadge);
                }
                
                playerInfo.appendChild(avatar);
                playerInfo.appendChild(nameSpan);
                
                // Status badge
                const statusBadge = document.createElement('span');
                statusBadge.className = 'player-status';
                
                if (player.isDrawing) {
                    statusBadge.textContent = 'Drawing';
                    statusBadge.classList.add('status-drawing');
                } else if (player.ready) {
                    statusBadge.textContent = 'Ready';
                    statusBadge.classList.add('status-ready');
                } else {
                    statusBadge.textContent = 'Not Ready';
                }
                
                // Add both sections to the list item
                li.appendChild(playerInfo);
                li.appendChild(statusBadge);
                
                // Highlight your own username
                if (player.username === username) {
                    li.style.border = '2px solid var(--success)';
                }
                
                playersList.appendChild(li);
            });
        });

        // Handle end game votes update
        socket.on('end_game_votes', (data) => {
            addSystemMessage(`End game vote: ${data.votes}/${data.total}`);
        });

        // Handle game errors
        socket.on('game_error', (data) => {
            addSystemMessage(data.message);
        });

        // Handle game end
        socket.on('game_ended', () => {
            gameInProgress = false;
            endGameButton.style.display = 'none';
            endGameButton.disabled = false;
            addSystemMessage("Game ended. Host can start a new game when players are ready.");
            startGameButton.disabled = !pictionary_players.every(player => player.ready);
        });

        // Assign host privileges
        socket.on('assign_host', (data) => {
            isHost = data.isHost;
            hostControls.style.display = isHost ? 'flex' : 'none';
            
            if (isHost) {
                addSystemMessage("You are the host! You can start the game when everyone is ready.");
            }
        });

        // Add these variables
        let gameInProgress = false;
        let endGameButton = document.createElement('button');
        endGameButton.id = 'end-game';
        endGameButton.textContent = 'Vote to End Game';
        endGameButton.style.background = 'var(--warning)';
        endGameButton.style.display = 'none';
        document.querySelector('.toolbar-group:last-child').appendChild(endGameButton);

        // Add event listener for end game button
        endGameButton.addEventListener('click', () => {
            socket.emit('vote_end_game', { username });
            endGameButton.disabled = true;
            endGameButton.textContent = 'Vote Submitted';
        });


        // Handle new round
        socket.on('new_round', (data) => {
            gameInProgress = true;
            startGameButton.disabled = true;
            isDrawer = data.drawer === username;
            roundInProgress = true;
            gameActive = true;
            gameStateElement.textContent = isDrawer ? "You are drawing!" : `${data.drawer} is drawing`;
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawHistory = [];
            
            // Reset timer
            roundTimer = 60;
            updateTimer();
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            
            if (isDrawer) {
                currentWord = data.word;
                displayWordToDrawer(data.word);
                addSystemMessage(`Your word to draw is: ${data.word}`);
            } else {
                // Display blank spaces for guessers
                displayWordToGuessers(data.word);
                addSystemMessage(`${data.drawer} is drawing now! Guess the word.`);
            }
        });
        
        // Display the word for the drawer
        function displayWordToDrawer(word) {
            wordDisplay.style.display = 'flex';
            wordDisplay.innerHTML = '';
            wordLetters = word.split('');
            
            wordLetters.forEach(letter => {
                const letterBox = document.createElement('div');
                letterBox.className = 'letter-box';
                letterBox.textContent = letter;
                wordDisplay.appendChild(letterBox);
            });
        }
        
        // Display blank spaces for guessers
        function displayWordToGuessers(word) {
            wordDisplay.style.display = 'flex';
            wordDisplay.innerHTML = '';
            wordLetters = word.split('');
            
            wordLetters.forEach((letter, index) => {
                if (letter === ' ') {
                    // For spaces between words
                    const spaceDiv = document.createElement('div');
                    spaceDiv.className = 'letter-blank';
                    wordDisplay.appendChild(spaceDiv);
                } else {
                    // For actual letters (show as underscore)
                    const letterBox = document.createElement('div');
                    letterBox.className = 'letter-box';
                    letterBox.textContent = '_';
                    letterBox.dataset.letter = letter;
                    letterBox.dataset.index = index;
                    wordDisplay.appendChild(letterBox);
                }
            });
        }
        
        // Update timer function
        function updateTimer() {
            if (roundTimer > 0) {
                roundTimer--;
                timerElement.textContent = roundTimer;
                
                // Change color as time runs out
                if (roundTimer <= 10) {
                    timerElement.style.color = 'var(--warning)';
                } else {
                    timerElement.style.color = '';
                }
            } else {
                clearInterval(timerInterval);
                timerElement.textContent = '0';
                
                // End the round automatically when time runs out
                socket.emit('round_timeout', { word: currentWord });
                gameStateElement.textContent = "Time's up!";
                
                // Disable drawing for all players
                roundInProgress = false;
            }
        }

        // Submit a guess
        submitGuessButton.addEventListener('click', () => {
            const guess = guessInput.value.trim();
            if (guess && !isDrawer && roundInProgress) {
                socket.emit('guess_pictionary', { guess, username });
                guessInput.value = '';
            }
        });
        
        // Handle enter key on guess input
        guessInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitGuessButton.click();
            }
        });

        // Handle correct guess
        socket.on('pictionary_correct', (data) => {
            const message = document.createElement('div');
            message.classList.add('chat-message', 'correct-guess');
            message.innerHTML = `<div class="sender">${data.username}</div>${data.username} guessed correctly!`;
            chatBox.appendChild(message);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Reveal the word if someone else guessed correctly
            if (data.username !== username && !isDrawer) {
                revealWord();
            }
        });

        // Handle shape drawing events
        socket.on('draw_shape', (data) => {
            if (isDrawer) return; // Don't process our own drawing events
            
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.lineWidth;
            
            if (data.type === 'line') {
                ctx.beginPath();
                ctx.moveTo(data.startX, data.startY);
                ctx.lineTo(data.endX, data.endY);
                ctx.stroke();
            } else if (data.type === 'rect') {
                const width = data.endX - data.startX;
                const height = data.endY - data.startY;
                ctx.strokeRect(data.startX, data.startY, width, height);
            } else if (data.type === 'circle') {
                ctx.beginPath();
                const radius = Math.sqrt(Math.pow(data.endX - data.startX, 2) + Math.pow(data.endY - data.startY, 2));
                ctx.arc(data.startX, data.startY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        });

        // Handle incorrect guess
        socket.on('pictionary_incorrect', (data) => {
            const message = document.createElement('div');
            message.classList.add('chat-message');
            message.innerHTML = `<div class="sender">${data.username}</div>${data.guess}`;
            chatBox.appendChild(message);
            chatBox.scrollTop = chatBox.scrollHeight;
        });
        
        // Add a system message to the chat
        function addSystemMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('system-message');
            messageElement.textContent = message;
            chatBox.appendChild(messageElement);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Reveal the word for guessers
        function revealWord() {
            const letterBoxes = wordDisplay.querySelectorAll('.letter-box');
            letterBoxes.forEach(box => {
                box.textContent = box.dataset.letter;
                box.classList.add('revealed');
            });
        }
        
        // Sync drawing for all clients
        socket.on('start_draw', (data) => {
            if (isDrawer) return; // Don't process our own drawing events
            
            ctx.beginPath();
            ctx.moveTo(data.x, data.y);
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Add to drawHistory
            drawHistory.push([{
                type: 'start',
                x: data.x,
                y: data.y,
                tool: data.tool,
                color: data.color,
                lineWidth: data.lineWidth
            }]);
        });

        socket.on('draw', (data) => {
            if (isDrawer) return; // Don't process our own drawing events
            
            ctx.lineTo(data.x, data.y);
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.lineWidth;
            ctx.stroke();

            // Add to the last path in drawHistory
            if (drawHistory.length > 0) {
                drawHistory[drawHistory.length - 1].push({
                    type: 'draw',
                    x: data.x,
                    y: data.y
                });
            }
        });

        socket.on('stop_draw', () => {
            if (isDrawer) return; // Don't process our own drawing events
            
            ctx.beginPath(); // End the current path
        });
        
        socket.on('draw_shape', (data) => {
            if (isDrawer) return; // Don't process our own drawing events
            
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.lineWidth;
            
            if (data.type === 'line') {
                ctx.beginPath();
                ctx.moveTo(data.startX, data.startY);
                ctx.lineTo(data.endX, data.endY);
                ctx.stroke();
            } else if (data.type === 'rect') {
                const width = data.endX - data.startX;
                const height = data.endY - data.startY;
                ctx.strokeRect(data.startX, data.startY, width, height);
            } else if (data.type === 'circle') {
                ctx.beginPath();
                const radius = Math.sqrt(Math.pow(data.endX - data.startX, 2) + Math.pow(data.endY - data.startY, 2));
                ctx.arc(data.startX, data.startY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        });

        socket.on('fill', (data) => {
            if (isDrawer) return; // Don't process our own fill events
            
            floodFill(data.x, data.y, data.color);
        });

        socket.on('clear_canvas', () => {
            if (isDrawer) return; // Don't process our own clear events
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawHistory = [];
        });
        
        socket.on('undo_canvas', () => {
            console.log('Undo event received');
            if (isDrawer) return; // Don't process our own undo events
            
            if (drawHistory.length > 0) {
                drawHistory.pop();
                console.log('Undoing last action');
                redrawCanvas();
            }
        });

        // Handle Pictionary system messages
        socket.on('pictionary_system_message', (data) => {
            const messageElement = document.createElement('div');
            messageElement.classList.add('system-message');
            messageElement.textContent = data.message;
            chatBox.appendChild(messageElement);
            chatBox.scrollTop = chatBox.scrollHeight;
        });
        
        // Handle round end
        socket.on('round_end', (data) => {
            roundInProgress = false;
            clearInterval(timerInterval);
            
            // Show the real word
            revealedWord.textContent = data.word;
            
            // Show scores
            scoreList.innerHTML = '';
            data.scores.forEach(score => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span>${score.username}</span>
                    <span class="score-value">+${score.points}</span>
                `;
                scoreList.appendChild(li);
            });
            
            // Start countdown for next round
            let countdown = 5;
            countdownElement.textContent = countdown;
            roundEndModal.style.display = 'flex';
            
            const countdownInterval = setInterval(() => {
                countdown--;
                countdownElement.textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    roundEndModal.style.display = 'none';
                }
            }, 1000);

            // Show end game button after round ends
            endGameButton.style.display = 'block';
            endGameButton.textContent = 'Vote to End Game';
            endGameButton.disabled = false;
        });
        
        // Word selection for drawer
        socket.on('word_selection', (data) => {
            const words = data.words;
            
            // Create word options
            wordOptions.innerHTML = '';
            words.forEach(word => {
                const wordOption = document.createElement('div');
                wordOption.className = 'word-option';
                wordOption.textContent = word;
                wordOption.addEventListener('click', () => {
                    socket.emit('word_selected', { word });
                    wordSelectionModal.style.display = 'none';
                });
                wordOptions.appendChild(wordOption);
            });
            
            wordSelectionModal.style.display = 'flex';
        });
    </script>
</body>
</html>